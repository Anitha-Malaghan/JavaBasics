Multithreading:
-------------------------------------------------------------------------------
1. Extending the Thread Class
        You can create a new thread by extending the Thread class and overriding its run() method.

2. Implementing the Runnable Interface
       Another way is to implement the Runnable interface, which provides more flexibility as it
       allows your class to extend another class.

3.  Using Executors and ExecutorService
        Java provides the ExecutorService interface for managing a pool of threads, which is part of the
        java.util.concurrent package. This approach is more scalable and is preferred for complex
        multithreading tasks.

        Using ExecutorService in Java provides a powerful and flexible way to manage thread pools and
        execute tasks asynchronously. Here are several ways to achieve multithreading using
        ExecutorService:
        -------------------------------------------
        There are 3 ways to achieve multithreading using ExecutorService
        -------------------------------------------
        1. Fixed Thread Pool
        A fixed thread pool creates a pool with a fixed number of threads. If all threads are active,
        additional tasks wait in a queue until a thread is available.

        2. Cached Thread Pool
          A cached thread pool creates new threads as needed but reuses previously created threads
          when available. This pool is ideal for executing many short-lived asynchronous tasks.






        1. Fixed Thread Pool
        A fixed thread pool creates a pool with a fixed number of threads. If all threads are active, additional tasks wait in a queue until a thread is available.

4.  Using Future and Callable
        If you need to return a result from a thread, you can use Callable along with Future.

5. Using ScheduledExecutorService for Scheduled Tasks
        To schedule tasks to run after a delay or to execute periodically, use ScheduledExecutorService.

In Java, achieving multithreading involves creating and managing multiple threads that run concurrently.

Thread Creation: You can create a thread by extending Thread or implementing Runnable.

ExecutorService: Use ExecutorService for managing a pool of threads efficiently.

Synchronization: Ensure thread safety using synchronization mechanisms
(e.g., synchronized blocks, Locks, and concurrency utilities like CountDownLatch, CyclicBarrier, and Semaphore).

Callable and Future: Use Callable and Future for tasks that return results.

Scheduled Tasks: Use ScheduledExecutorService for scheduling tasks.
--------------------------------------------------------------------------------
Best Uses:
--------------------------------------------------------------------------------
CountDownLatch: Best for one-time events where you need a thread
(or threads) to wait for a specific number of operations to complete.

CyclicBarrier: Best for scenarios where multiple threads need to repeatedly
wait for each other at a barrier point before proceeding.

Semaphore: Best for limiting the number of threads that can access a
resource or perform a task simultaneously.